# loading packages
library(rgdal) 
library(spdep)

# poviat map
pov<-readOGR(".", "poviats") # 380 units 
pov<-spTransform(pov, CRS("+proj=longlat +datum=NAD83"))

# matrix of weights according to the common border criterion
cont.sp<-as(pov, "SpatialPolygons") # conversion of polygons to class sp
cont.nb<-poly2nb(cont.sp, queen=T) # conversion of sp to class nb

# creation of weight matrix standardized by lines up to 1 (option W)
cont.listw<-nb2listw(cont.nb, style="W") 
cont.listw # displays a summary of the weight matrix

# poviats’ coordinates of measures
crds.pov<-coordinates(pov)
colnames(crds.pov)<-c("cx", "cy")

plot(pov) # contour map Fig. 4.2
plot(cont.nb, crds.pov, add=TRUE) # neighborly layer

# conversion to matrix class
cont.mat<-nb2mat(cont.nb)
cont.mat[1:5, 1:5]

voi<-readOGR(".", "voivodeships") # 16 units 
voi<-spTransform(voi, CRS("+proj=longlat +datum=NAD83"))
names_voi<-as.character(voi$jpt_name_) # region names vector
names_voi

cont.voi.nb<-poly2nb(as(voi, "SpatialPolygons"), row.names=names_voi)
cont.voi.mat<-nb2mat(cont.voi.nb) # conversion to matrix class
cont.voi.mat[1:5, 1:5]

names_voi[cont.voi.nb[[which(names_voi=="lubuskie")]]]

crds.voi<-coordinates(voi) # centroids of NTS 2 voivodeships
head(crds.voi)

# matrix k = 5 nearest neighbors for area data
voi.knn<-knearneigh(crds.voi, k=5) # a knn object is created
voi.knn.nb<- knn2nb(voi.knn) 

#Fig.4.3 – connections of k nearest neighbors
plot(voi, main=" K nearest neighbors, k=5")	# regional outline
plot(voi.knn.nb, crds.voi, add=TRUE) # relationship layer

# checking the symmetry of the matrix
print(is.symmetric.nb(voi.knn.nb))

voi.knn.sym.nb<-make.sym.nb(voi.knn.nb)
print(is.symmetric.nb(voi.knn.sym.nb))

# creating a listw class object
voi.knn.sym.listw<-nb2listw(voi.knn.sym.nb)

library(dplyr)
companies<-read.csv("geoloc data.csv", header=TRUE, dec=",", sep=";")
companies.sub<-sample_n(as_tibble(companies), size=100, replace=FALSE)
names(companies.sub)

class(companies.sub)

# matrix k = 5 nearest neighbors for point data
companies.knn<-knearneigh(as.matrix(companies.sub[,23:24]), k=5) # knn class object
companies.knn.nb<- knn2nb(companies.knn) 

# Fig. 4.3b - relations k of nearest neighbors
plot(voi[voi$jpt_name_=="lubelskie",]) # drawing a map slice
plot(companies.knn.nb, as.matrix(companies.sub[,23:24]), add=TRUE) # relationship layer

print(is.symmetric.nb(companies.knn.nb))
companies.knn.sym.nb<-make.sym.nb(companies.knn.nb)
print(is.symmetric.nb(companies.knn.sym.nb))

# creating a listw class object  
companies.knn.sym.listw<-nb2listw(companies.knn.sym.nb)
summary(companies.knn.sym.listw)

# Fig.4.4a - a matrix of neighbors within a radius of d km
conti.d.30<-dnearneigh(crds.pov, 0, 30, longlat=TRUE)
plot(pov) # background map
plot(conti.d.30, crds.pov, add=TRUE) # neighborly relations

# convert nb to matrix
conti.d.30.m<-nb2mat(conti.d.30, zero.policy=TRUE)
a<-colMeans(t(conti.d.30.m)) # averages in rows
pov$a<-a # appending a value vector to shapefile
spplot(pov, "a") # Fig.4.4b

conti.d.30.listw<-nb2listw(conti.d.30)
Error in command 'nb2listw(conti.d.30) #Empty neighbour sets found

# matrix of neighbors within a radius of d km, so that each region has a neighbor
kkk<-knn2nb(knearneigh(crds.pov))
all<-max(unlist(nbdists(kkk, crds.pov)))
all.nb<-dnearneigh(crds.pov, 0, all)
summary(all.nb, crds.pov)

plot(pov, border="grey") # Fig.4.5
plot(all.nb, coords.pov, add=TRUE)

# inverse matrix
poviats.knn<-knearneigh(crds.pov, k=379) 
poviats.nb<-knn2nb(poviats.knn)
dist<-nbdists(poviats.nb, crds.pov) 
dist1<-lapply(dist, function(x) 1/x) # list class object
poviats.dist.listw<-nb2listw(poviats.nb, glist=dist1)
summary(poviats.dist.listw)	

# power matrix
dist2<-lapply(dist, function(x) x**(-2)) 
poviats.dist.listw2<-nb2listw(poviats.nb, glist=dist2)

# exponential matrix
dist3<-lapply(dist, function(x) exp(-1.5*x)) 
poviats.dist.listw3<-nb2listw(poviats.nb, glist=dist3)

summary(conti.d.30) # summary of the nb class neighborhood matrix

all.listw<-nb2listw(all.nb) 
summary(unlist(all.listw$weights))

   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
0.03571 0.08333 0.12500 0.13709 0.16667 1.00000

all.mat<-nb2mat(all.nb)
summary(all.mat)
      
table(card(all.nb))

voi.knn.mat<-nb2mat(voi.knn.nb)
print(voi.knn.mat)

cont.listw$weights

# launching the editing interface
edit.nb(voi.knn.nb, crds.voi, polys=voi)

cont.nb.voi

logic<-c(F,F,F,T,F,F,F,F,F,F,F,F,F,F,F,F)
name<-c("mazowieckie")
id<-c(4)

change1<-droplinks(cont.nb.voi, logic)
change2<-droplinks(cont.nb.voi, name)
change3<-droplinks(cont.nb.voi, id)	
change1 	# others give identical results
      
subset<-c(F,T,F,T,F,F,F,F,F,F,T,F,F,F,F,F)
subset.voi<-subset.nb(cont.nb.voi, subset)
subset.voi

cont.nb.voi.self<-include.self(cont.nb.voi)
cont.nb.voi.self

par(mfrow=c(1,3)) # 1 x 3 split window
par(mar=c(5.1, 2, 4.1, 1))

plot(voi, main="complement.nb()")
plot(complement.nb(change1), crds.voi, add=T)

plot(voi, main="intersect.nb()")
plot(intersect.nb(cont.nb.voi, change1), crds.voi, add=T)

plot(voi, main="setdiff.nb()")
plot(setdiff.nb(cont.nb.voi, change1), crds.voi, add=T)

par(mfrow=c(1,1)) # 1 x 1 split window

head(levels(pov$jpt_name_))

pov$SHOCK<-rep(0,380)
pov$SHOCK[pov$jpt_name_=="poviat £ódŸ"]<-1 	#£ódŸ
pov$SHOCK[pov$jpt_name_=="poviat Warszawa"]<-1 	#Warszawa
pov$SHOCK[pov$jpt_name_=="poviat Gdañsk"]<-1 	#Gdañsk
pov$SHOCK[pov$jpt_name_=="poviat Poznañ"]<-1 	#Poznañ
spplot(pov, "SHOCK") 					#shock centers Fig. X
      
# spatial lag of the SHOCK variable - first row
pov$lagg<-lag.listw(cont.listw, pov$SHOCK)
summary(pov$lagg)

spplot(pov, "lagg") 			# first order lag

# spatial lag of the SHOCK variable - second row
poviats.2.list<-nblag(cont.nb, 2)
poviats.2.nb<-nblag_cumul(poviats.2.list)
pov$lagg<-lag.listw(nb2listw(poviats.2.nb), pov$SHOCK) 
#spplot(pov, "lagg") 	# Fig.4.9a - second order lag

# spatial lag of the SHOCK variable - third row
poviats.3.list<-nblag(cont.nb, 3)
poviats.3.nb<-nblag_cumul(poviats.3.list)
pov$lagg<- lag.listw(nb2listw(poviats.3.nb), pov$SHOCK)
spplot(pov, "lagg") 	# Fig.4.9b - third order lag

data<-read.csv("data_pov_2019.csv", header=TRUE, dec=",", sep=";")
sub<-data[data$rok==2017,]
names(sub)

table(sub$voi_name)

matt<-matrix(0, nrow=380, ncol=380) #creating empty matrix

names<-levels(sub$voi_name)
names
for(i in 1:16){
c1<-which(sub$voi_name==names[i])
matt[c1, c1]<-1}
diag(matt)<-0
 
vec<-rowSums(matt) # sums in rows - de facto number of neighbors
matt.W<-matt/vec # matrix standardization
matt.listw<-mat2listw(matt.W) # conversion to listw
matt.listw

# visualization of values in the weight matrix
a<-apply(matt.W, 1, max) 	# max in rows
library(GISTools)
choropleth(pov, a)		# value of weights in the poviat
plot(voi, add=TRUE, lwd=2) 	# voivodship outline

sub<-data[data$rok==2017, ]
names(sub)
sub.k<-sub[,c(26,37,16)]

library(factoextra)
library(RColorBrewer)
fviz_nbclust(sub.k, kmeans, method="silhouette") # Fig.4.11a
clus<-eclust(sub.k, "kmeans", hc_metric="euclidean",k=2, graph=FALSE)

brks<-c(0,1,2,3)
cols<-brewer.pal(3, "Purples")
plot(pov, col=cols[findInterval(clus$cluster, brks)]) # Fig.4.11b

matt<-matrix(0, nrow=380, ncol=380) # creating an empty matrix
for(i in 1:2){
c1<-which(clus$cluster==i)
matt[c1, c1]<-1}
diag(matt)<-0

vec<-rowSums(matt) # sums in rows - de facto number of neighbors
matt.W<-matt/vec # matrix standardization
matt.listw<-mat2listw(matt.W) # conversion to listw
matt.listw

# visualization of values in the weight matrix
a<-apply(matt.W, 1, max) 	# max in rows
library(GISTools)
choropleth(pov, a)		# value of weights in the poviat
plot(voi, add=TRUE, lwd=2) 	# voivodeship outline

companies<-read.csv("geoloc data.csv", header=TRUE, dec=",", sep=";")
crds.Lublin<-c(22.4236877, 51.2180254) # coordinates of Lublin

# xy coordinates of companies - SpatialPoints class object
loc<-SpatialPoints(companies[,23:24], proj4string=CRS("+proj=longlat +datum=NAD83"))
head(loc)

# vector distance of all points from the center - Lublin
odle<-spDistsN1(loc, crds.Lublin, longlat = TRUE)

# color palette
library(wesanderson)
cols<-wes_palette(n=8, name="Darjeeling1", type="continuous")
cols	# Fig.4.12 – palette colors 

# a point map that defines the distance between the point and the center in color (odle)

brks<-c(0, 2, 25, 50, 75, 100, 125, 150)
lubelskie.voi<- voi[voi$jpt_name_=="lubelskie",] # creating a map slice
lubelskie.pov<-pov[50:73,] # creating a slice in a poviat facility
plot(lubelskie.voi)
plot(lubelskie.pov, add=TRUE)

points(companies[,23:24], col=cols[findInterval(odle, brks)], 
pch=21, bg=cols[findInterval(odle, brks)], cex=0.2)

legend("bottomleft", legend=brks, pt.bg=cols, bty="n", pch=21)
title(main=" Distance of points from the center ")
savePlot(filename="dists", type="jpg")

# checking the affiliation of points to areas
lubelskie.pov<-pov[50:73,] # creating a slice at the poviat building
loc<-SpatialPoints(companies[,23:24], proj4string=CRS("+proj=longlat +datum=NAD83"))

# rewriting points to areas (poviats)
companies.over<-over(loc, lubelskie.pov) # z pakietu sp
dim(companies.over)

names(companies.over) # the same result will be obtained from names (pov)

head(companies.over$jpt_name_)

the.same<-zerodist(loc)
head(takie.same)

# drawing new points in the map area and converting them to the matrix class
# draw points on the map, options: random | regular | stratified
# | nonaligned | hexagonal | clustered | fibonacci

pl<-readOGR(".", "Country") # outline map of Poland without internal divisions
pl<-spTransform(pl, CRS("+proj=longlat +datum=NAD83"))

newpoints<-spsample(pl, 20000, type="stratified") 
newpoints.df<-as.data.frame(newpoints)		# class conversion
newpoints.m<-as.matrix(newpoints.df)		# class conversion

# checking the affiliation of a point to a region and choosing a key variable
where<-over(newpoints, voi) 	
newpoints.df$voi<-gdzie$jpt_name_ 	# variable about the region

head(newpoints.df)

dim(newpoints.df)
[1] 19977     3

regions<-levels(newpoints.df$voi) 	# voivodeship names
regions

# loading poviat data that has the identifier of region centers
enempl<-read.csv("bezr2017.csv", header=TRUE, dec=",", sep=";")

# adding centrod coordinates to the data set
enempl$crds<-coordinates(pov) # added as a matrix in the data frame	

# selection of relevant column - name voivodeship and geographical coordinates
capitals.xy<-enempl[enempl$capitals_voi==1, c(6,102)] 

# case correction 
capitals.xy$voivodeshipo<-tolower(capitals.xy$voivodeshipo) 
capitals.xy<-capitals.xy[1:16,]

head(capitals.xy)

# joining data sets by key-variable
odle<-merge(newpoints.df, capitals.xy, by.x="voi", by.y="voivodeship", all.x=TRUE, sort=FALSE)
names(odle)

head(odle)

# counting the distance between coordinate pairs
library(raster)
for(i in 1:dim(odle)[1]){
odle$odle[i]<-pointDistance(odle[i,2:3],odle$crds[i,], lonlat=FALSE)}

head(odle)

# value graph in point
library(fields)
quilt.plot(odle[,2:3], odle$odle) # Fig.4.13a
	 
library(cluster)
library(factoextra)
library(wesanderson) 
library(GISTools)

# coordinate clustering
c2<-clara(companies[,23:24], 5, metric="euclidean", sampsize=1000)

# a combination of clustering and membership verification results
points<-cbind(companies[,23:24], companies.over$jpt_name_, c2$clustering)
head(points)
names(points)<-c("xx", "yy", "poviat", "cluster")
head(points)

# summary of points belonging to poviats according to clusters from CLARA
# i.e. what poviats are points from the first CLARA cluster
unique(points$poviat[points$cluster==1]) 

# checking how many points there are within polygons (poviats)
How.much.pts.in.pov<-poly.counts(loc, lubelskie.pov)# from GISTools:: 

# point density in relation to the surface - Fig. Xb
choropleth(lubelskie.pov, how.many.pts.in.pov/poly.areas(lubelskie.pov))

NN<-1500 # number of observations
samm<-spsample(pov, n=NN, type="random") # spatial sample
val<-rnorm(NN, mean=100, sd=20) # drawn values
samm.df<-as.data.frame(samm)
samm.df$val<-val

head(samm.df)

brks<-c(40,60,80,100,120,140,160)
cols<-wes_palette(n=8, name="BottleRocket2", type="continuous")
plot(pov, border="grey80") #Fig.4.14a
points(samm.df[,1:2], pch=".", cex=5, col=cols[findInterval(samm.df[,3], brks)])

# checking the point's affiliation with the area 
samm.over.pov<-over(samm, pov) # do poviats
samm.over.voi<-over(samm, voi) # do voivodeship
samm.df$pov<-samm.over.pov$jpt_name_
samm.df$voi<-samm.over.voi$jpt_name_

head(samm.df)

# aggregation of point data
result<-aggregate(samm.df$val, by=list(samm.df$voi), sum)
voi.df<-as.data.frame(voi)
voi.df$id<-1:16
voi.df<-voi.df[,c(6,30)]
voi.df.m<-merge(voi.df, result, by.x="jpt_name_", by.y="Group.1")

# aggregate data sorting
library(doBy)
result.sort<-orderBy(~id, data=voi.df.m)

# colorful voivodeship map Fig.4.14b
library(RColorBrewer)
library(classInt)
variable<-result.sort$x
summary(variable)
compartments<-8
colors<-brewer.pal(compartments, "BuPu") # wybór kolorów
class<-classIntervals(variable, compartments, style="pretty")
color.table<-findColours(class, colors) 
plot(voi, col=color.table)
legend("bottomleft", legend=names(attr(color.table, 
"table")), fill=attr(color.table, "palette"), cex=0.75, bty="n")
title(main="Sums according to voivodeship")

# closest neighbors of generated points
samm.knn<-knearneigh(samm, k=2) # class knn object k = 2
samm.nb<-knn2nb(samm.knn) 
samm.listw<-nb2listw(samm.nb) # conversion class nb to listw
samm.lag<-lag.listw(samm.listw, samm.df$val) # spatial lag
dev.off()
plot(samm.df$val, samm.lag)

library(spatstat)
lub.voi<-voi[voi$jpt_name_=="lubelskie",] # creating a map slice
lub.owin<-as(lub.voi, "owin")

# extraction of unique points and random sampling
cord<-as.matrix(cbind(companies$coords.x1, companies$coords.x2))
cord1<-unique(cord)
x<-sample(1:length(cord1), 100)
x<-order(x)
cord2<-cord1[x,]

# construction of the spatial object and tessellation
lub.ppp<-ppp(x=cord2[,1], y=cord2[,2], window=lub.owin)
lub.tes<-dirichlet(lub.ppp) # Dirichlet tessellation
plot(lub.tes, main=" Tessellation for n = 100 points ") # Fig.4.16a
plot(lub.ppp, add=TRUE, pch=".", col="darkblue", cex=2)
degAxis(1)
degAxis(2)

tes.poly<-as(lub.tes, "SpatialPolygons") 

library(tripack)
lub.vm <- voronoi.mosaic(cord2[,1], cord2[,2])
plot(lub.vm) # Fig.Xb
plot(lub.voi, add=TRUE, lwd=2, border="red")

lub.vp <- voronoi.polygons(lub.vm)
head(lub.vp)

# reading poviat data
enempl<-read.csv("bezr2017.csv", header=TRUE, dec=",", sep=";")
names(enempl)

# map of poviats and spatial weight matrix
pov<-readOGR(".", "poviats") # 16 units 
pov<-spTransform(pov, CRS("+proj=longlat +datum=NAD83"))

cont.nb<-poly2nb(as(pov, "SpatialPolygons")) 	# from the spdep:: package
cont.listw<-nb2listw(cont.nb, style="W")	# from the spdep:: package

moran(enempl$X2011.06, cont.listw, length(cont.nb), Szero(cont.listw))

moran.test(enempl$X2011.06, cont.listw)

m3<-moran.test(enempl$X2011.06, cont.listw, randomisation=FALSE)
m3

#pvalue for I Morana (normal distribution)
pval.norm<-1-pnorm(m3$statistic, mean=0, sd=1)
pval.norm

moran.mc(enempl$X2011.06, cont.listw, 99)

variable<-enempl$X2011.06
variable.std<-((variable-mean(variable))/sd(variable))
moran.plot(variable.std, cont.listw, labels=as.character(enempl$poviat), pch=19, quiet=F)

x<-enempl$X2011.06 		# extracting the variable
zx<-scale(x) 			# variable standardization
mean(zx) 				# average control
sd(zx) 				# standard deviation control
wzx<-lag.listw(cont.listw, zx) # spatial lag of x
morlm<-lm(wzx~zx) 		# regression   
slope<-morlm$coefficients[2] 	# directional coefficient
intercept<-morlm$coefficients[1] # constant
par(pty="s") 			# square chart window
plot(zx, wzx, xlab="zx",ylab="spatial lag zx", pch="*") 
abline(intercept, slope) 	# regression line
abline(h=0, lty=2) 		# horizontal line at y = 0
abline(v=0, lty=2) 		# vertical line at x = 0

# map of belonging to the quarters of the Moran scatter chart
# creating a variable for analysis
x<-enempl$X2011.06 # creating a variable for analysis
zx<-scale(x) # variable standardization
wzx<-lag.listw(cont.listw, zx) # spatial lag of x
cond1<-ifelse(zx>=0 & wzx>=0, 1,0) # I quarter
cond2<-ifelse(zx>=0 & wzx<0, 2,0) # II quarter
cond3<-ifelse(zx<0 & wzx<0, 3,0) # III quarter
cond4<-ifelse(zx<0 & wzx>=0, 4,0) # IV quarter
cond.all<-as.data.frame(cond1+cond2+cond3+cond4) 

# chart - color map
brks<-c(1,2,3,4)
cols<-c("grey25", "grey60", "grey85", "grey45")
par(mar=c(5.1,1,4.1,1))
plot(pov, col=cols[findInterval(cond.all$V1, brks)])

legend("bottomleft", legend=c("I quarter - HH - high surrounded by high ", " II quarter - LH - low surrounded by high ", " III quarter - LL - low surrounded by low ", " IV exercise - HL - high surrounded by low "), fill=cols, bty="n", cex=0.8)

title(main="Regions belonging to quarters from the Moran scatter plot")

geary(enempl$X2011.06, cont.listw, length(cont.nb), length(cont.nb)-1, Szero(cont.listw))

geary.test(spNamedVec("X2011.06", enempl), cont.listw)

geary.mc(enempl$X2011.06, cont.listw, 99)

summary(enempl$X2011.06)

head(enempl$X2011.06)

variable.f<-factor(cut(enempl$X2011.06, breaks=c(0,10, 20, 40), labels=c("low", "medium", "high")))

head(variable.f)

# graphic parameters
brks1<-c(0, 10, 20, 40) 
cols<-c("green", "blue", "red")

# scatter plot of subsequent values of the tested variable - Fig.4.20a
plot(enempl$X2011.06, bg=cols[findInterval(enempl$X2011.06, brks1)], pch=21)
abline(h=c(10,20,40), lty=3)

# spatial distribution of values into three distinguished groups - Fig.4.20b
plot(pov, col=cols[findInterval(enempl$X2011.06, brks1)])
plot(voi, add=TRUE, lwd=2)
title(main="Unemployment in June 2011")
legend("bottomleft", legend=c("low", "medium", "high"), leglabs(brks1), fill=cols, bty="n")

joincount.test(variable.f, cont.listw)

joincount.mc(variable.f, cont.listw, 99)
	 
joincount.multi(variable.f, cont.listw)

locM<-localmoran(spNamedVec("X2011.06", enempl), cont.listw)
oid1<-order(enempl$ID_MAPA)
printCoefmat(data.frame(locM[oid1,], row.names=enempl$poviat[oid1]), check.names=FALSE)

# duplicate names vector
dupli<-c("Poviat tomaszowski", "Poviat kroœnieñski", "Poviat brzeski", "Poviat ostrowski", "Poviat opolski", "Poviat grodziski", "Poviat nowodworski", "Poviat bielski", "Poviat œredzki", "Poviat œwidnicki")

# change data type from factor to character
enempl$poviat<-as.character(enempl$poviat)

# loop that adds an apostrophe to the second instance of names
for(i in 1: length(dupli)){
a<-which(enempl$poviat==dupli[i])[2]
enempl$poviat[a]
enempl$poviat[a]<-paste0(as.character(enempl$poviat[a]), "'")}

# restoring the original class variable
enempl$poviat<-as.factor(enempl$poviat)

# code generating a list of local Moran statistics with region names assigned
locM<-localmoran(spNamedVec("X2011.06", enempl), cont.listw)
oid1<-order(enempl$ID_MAPA)
locMorMat<-printCoefmat(data.frame(locM[oid1,], row.names=enempl$poviat[oid1]), check.names=FALSE)

# printing of the first six significant values <0.05 head(locMorMat[locMorMat$Pr.z...0.<0.05,])

# printing significant values> 0.95
locMorMat[locMorMat$Pr.z...0.>0.95,]

# map of the significance of Moran's local statistics
names(locMorMat)[5]<-"Prob"
brks<-c(min(locMorMat[,5]), 0.05000, 0.95000, max(locMorMat[,5]))
cols<-c("grey30", "grey90", "grey60")

plot(pov, col=cols[findInterval(locMorMat[,5], brks)])
legend("bottomleft", legend=c("surrounded by relatively high values, locM>0", " irrelevant ", " surrounded by relatively low values, locM<0"), fill=cols, bty="n", cex=0.75)
title(main=" Local Moran statistics ", cex=0.7)
plot(voi, add=TRUE, lwd=2)

# local Gi statistics
locG<-localG(enempl$X2011.06, cont.listw)
# locGstar<-localG(enempl$X2011.06, nb2listw(include.self(cont.nb)))
summary(locG)

# significance t-student test for n=100 
sig<-ifelse(locG<=-3.289 | locG>=3.289, "*", " ")
which(sig=="*")

enempl[which(sig=="*"), c(3,6,10,18)]

# graph of relevant locG statistics
brks<-c(-10,-3.289, 3.289, 10)
cols<-c("grey40", "grey85", "grey55")
cols<-c("red", "grey85", "green")
plot(pov, col=cols[findInterval(locG, brks)])
legend("bottomleft", legend=c("G significant - surrounded by relatively low values", "G insignificant", "G significant - surrounded by relatively high values") , fill=cols, bty="n", cex=0.75)
title(main="relevant statistics G")

# local Gi statistics
locG<-localG(enempl$X2011.06, cont.listw)
a<-summary(locG)

# graph of Gi statistics
brks<-c(a[1], a[2], a[3], a[5], a[6])
colfunc<-colorRampPalette(c("royalblue", "springgreen", "yellow", "red"))
coli<-colfunc(5)
plot(pov, col=coli[findInterval(locG, brks)], main="Statystyki Gi")
legend("bottomleft", legend=c("Bardzo low", "Low", "Medium", "High", "Bardzo high") , fill=coli, bty="n")

#local Hi LOSH
locH<-LOSH(enempl$X2011.06, cont.listw, a=2, var_hi=TRUE, zero.policy=TRUE, na.action=na.exclude)
summary(locH)

b<-summary(locH[,"Hi"])
b

# LOSH statistics chart
brks<-c(b[1], b[2], b[3], b[5], b[6])
plot(pov, col=coli[findInterval(locH[,"Hi"], brks)])
legend("bottomleft", legend=c("Very low", "Low", "Medium", "High", "Very high") , fill=coli , bty="n")
title(main="Statistics Hi")

library(spatialEco) # calculations, crossCorrelation()
library(GISTools) # graphics, choropleth()

cont.mat<-nb2mat(cont.nb) # W matrix converted to class matrix

x1<-enempl[,101]
x2<-enempl[,100] # date month to month

# version with matrix W
ii<-crossCorrelation(x1, x2, w=cont.mat, type=c("LSCI", "GSCI"), k=99, scale.xy=FALSE, scale.partial=TRUE, scale.matrix=TRUE, alpha=0.05)
ii

# version with coordinates and distance
iii<-crossCorrelation(x1, x2, coords=crds.pov, type = c("LSCI", "GSCI"), k=99, dist.function="inv.pover", scale.xy=FALSE, scale.partial=TRUE, scale.matrix=FALSE, alpha=0.05)
iii

cor(x1,x2) # Pearson correlation

head(iii$SCI[,"lsci.xy"]) # accessing the result

# mapping of result ii Fig.4.24a
choropleth(pov, ii$SCI[,"lsci.xy"])
shades<-auto.shading(ii$SCI[,"lsci.xy"])
choro.legend(14, 50.25, shades, cex=0.65, bty="n")
title(main=" Matrix of common border date month to month")

# mapping of result iii Fig.4.24b
choropleth(pov, iii$SCI[,"lsci.xy"])
shades<-auto.shading(iii$SCI[,"lsci.xy"])
choro.legend(14, 50.25, shades, cex=0.65, bty="n")
title(main=" Inverse square distance matrix date month to month")

# correlogram based on the classic correlation coefficient
corr.classic<-sp.correlogram(cont.nb, enempl$X2018.05, order=6, method="corr")
print(corr.classic)

stat<-(dim(enempl)[1]-2)^0.5*corr.classic$res/(1-corr.classic$res^2)^0.5
pvalue<-1-pnorm(abs(stat), mean=0, sd=1)
corr.classic.sig<-cbind(corr.classic$res, stat, pvalue)
options(scipen=999, digits=2)
corr.classic.sig

corr.moran<-sp.correlogram(cont.nb, enempl$X2018.05, order=6, method="I")
print(corr.moran)

plot(corr.classic)
plot(corr.moran)

library(spatialEco)
enempl$crds<-crds.pov # adding xy coordinates to the data set
enempl.lim<-enempl[,c(102,101)] # data.frame coordinates + 1 one variable
class(enempl.lim)		# data.frame class
coordinates(enempl.lim)<-enempl.lim[,1] # definition of coordinates
class(enempl.lim)		# already the SpatialPointsDataFrame class

a<-correlogram(x=enempl.lim, v=enempl.lim@data[,'X2018.05'], dist=35, ns=99, latlong=TRUE, dmatrix=TRUE)

attributes(a)
1


